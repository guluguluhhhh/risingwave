# This file is automatically generated. See `src/frontend/planner_test/README.md` for more information.
- name: basic with LOCF
  sql: |
    CREATE TABLE t (id INT, ts TIMESTAMP, val DOUBLE, PRIMARY KEY(ts));
    SELECT * FROM GAP_FILL(t, ts, INTERVAL '1' MINUTE, LOCF(val));
  logical_plan: |-
    LogicalProject { exprs: [t.id, t.ts, t.val] }
    └─LogicalGapFill { time_col: $1, interval: '00:01:00':Interval, fill_strategies: [BoundFillStrategy { strategy: Locf, target_col: $2 }] }
      └─LogicalScan { table: t, columns: [t.id, t.ts, t.val, t._rw_timestamp] }
  stream_plan: |-
    StreamMaterialize { columns: [id, ts, val], stream_key: [ts], pk_columns: [ts], pk_conflict: NoCheck }
    └─StreamGapFill { time_col: $1, interval: '00:01:00':Interval, fill_strategies: [BoundFillStrategy { strategy: Locf, target_col: $2 }] }
      └─StreamExchange { dist: Single }
        └─StreamTableScan { table: t, columns: [t.id, t.ts, t.val], stream_scan_type: ArrangementBackfill, stream_key: [t.ts], pk: [ts], dist: UpstreamHashShard(t.ts) }
  eowc_stream_error: |-
    Not supported: GAP_FILL with EMIT ON WINDOW CLOSE requires a watermark on the time column.
    HINT: Please define a watermark on the time column (column index 1).
- name: with INTERPOLATE
  sql: |
    CREATE TABLE t (ts TIMESTAMP, val DOUBLE, PRIMARY KEY(ts));
    SELECT * FROM GAP_FILL(t, ts, INTERVAL '1' MINUTE, INTERPOLATE(val));
  logical_plan: |-
    LogicalProject { exprs: [t.ts, t.val] }
    └─LogicalGapFill { time_col: $0, interval: '00:01:00':Interval, fill_strategies: [BoundFillStrategy { strategy: Interpolate, target_col: $1 }] }
      └─LogicalScan { table: t, columns: [t.ts, t.val, t._rw_timestamp] }
  stream_plan: |-
    StreamMaterialize { columns: [ts, val], stream_key: [ts], pk_columns: [ts], pk_conflict: NoCheck }
    └─StreamGapFill { time_col: $0, interval: '00:01:00':Interval, fill_strategies: [BoundFillStrategy { strategy: Interpolate, target_col: $1 }] }
      └─StreamExchange { dist: Single }
        └─StreamTableScan { table: t, columns: [t.ts, t.val], stream_scan_type: ArrangementBackfill, stream_key: [t.ts], pk: [ts], dist: UpstreamHashShard(t.ts) }
  eowc_stream_error: |-
    Not supported: GAP_FILL with EMIT ON WINDOW CLOSE requires a watermark on the time column.
    HINT: Please define a watermark on the time column (column index 0).
- name: with KEEPNULL strategy
  sql: |
    CREATE TABLE t (ts TIMESTAMP, name VARCHAR, PRIMARY KEY(ts));
    SELECT * FROM GAP_FILL(t, ts, INTERVAL '1' MINUTE, KEEPNULL(name));
  logical_plan: |-
    LogicalProject { exprs: [t.ts, t.name] }
    └─LogicalGapFill { time_col: $0, interval: '00:01:00':Interval, fill_strategies: [BoundFillStrategy { strategy: Null, target_col: $1 }] }
      └─LogicalScan { table: t, columns: [t.ts, t.name, t._rw_timestamp] }
  stream_plan: |-
    StreamMaterialize { columns: [ts, name], stream_key: [ts], pk_columns: [ts], pk_conflict: NoCheck }
    └─StreamGapFill { time_col: $0, interval: '00:01:00':Interval, fill_strategies: [BoundFillStrategy { strategy: Null, target_col: $1 }] }
      └─StreamExchange { dist: Single }
        └─StreamTableScan { table: t, columns: [t.ts, t.name], stream_scan_type: ArrangementBackfill, stream_key: [t.ts], pk: [ts], dist: UpstreamHashShard(t.ts) }
  eowc_stream_error: |-
    Not supported: GAP_FILL with EMIT ON WINDOW CLOSE requires a watermark on the time column.
    HINT: Please define a watermark on the time column (column index 0).
- name: mixed strategies
  sql: |
    CREATE TABLE t (ts TIMESTAMP, temp DOUBLE, status VARCHAR, PRIMARY KEY(ts));
    SELECT * FROM GAP_FILL(t, ts, INTERVAL '1' MINUTE, INTERPOLATE(temp), KEEPNULL(status));
  stream_plan: |-
    StreamMaterialize { columns: [ts, temp, status], stream_key: [ts], pk_columns: [ts], pk_conflict: NoCheck }
    └─StreamGapFill { time_col: $0, interval: '00:01:00':Interval, fill_strategies: [BoundFillStrategy { strategy: Interpolate, target_col: $1 }, BoundFillStrategy { strategy: Null, target_col: $2 }] }
      └─StreamExchange { dist: Single }
        └─StreamTableScan { table: t, columns: [t.ts, t.temp, t.status], stream_scan_type: ArrangementBackfill, stream_key: [t.ts], pk: [ts], dist: UpstreamHashShard(t.ts) }
  eowc_stream_error: |-
    Not supported: GAP_FILL with EMIT ON WINDOW CLOSE requires a watermark on the time column.
    HINT: Please define a watermark on the time column (column index 0).
- name: with timestamptz
  sql: |
    CREATE TABLE t (ts TIMESTAMPTZ, val INT, PRIMARY KEY(ts));
    SELECT * FROM GAP_FILL(t, ts, INTERVAL '1' HOUR, LOCF(val));
  stream_plan: |-
    StreamMaterialize { columns: [ts, val], stream_key: [ts], pk_columns: [ts], pk_conflict: NoCheck }
    └─StreamGapFill { time_col: $0, interval: '01:00:00':Interval, fill_strategies: [BoundFillStrategy { strategy: Locf, target_col: $1 }] }
      └─StreamExchange { dist: Single }
        └─StreamTableScan { table: t, columns: [t.ts, t.val], stream_scan_type: ArrangementBackfill, stream_key: [t.ts], pk: [ts], dist: UpstreamHashShard(t.ts) }
  eowc_stream_error: |-
    Not supported: GAP_FILL with EMIT ON WINDOW CLOSE requires a watermark on the time column.
    HINT: Please define a watermark on the time column (column index 0).
- name: with projection and filter
  sql: |
    CREATE TABLE t (id INT, ts TIMESTAMP, val DOUBLE, PRIMARY KEY(ts));
    SELECT id, ts FROM GAP_FILL(t, ts, INTERVAL '1' MINUTE, LOCF(val)) WHERE id = 1;
  stream_plan: |-
    StreamMaterialize { columns: [id, ts], stream_key: [ts], pk_columns: [ts], pk_conflict: NoCheck }
    └─StreamFilter { predicate: (t.id = 1:Int32) }
      └─StreamGapFill { time_col: $1, interval: '00:01:00':Interval, fill_strategies: [BoundFillStrategy { strategy: Locf, target_col: $2 }] }
        └─StreamExchange { dist: Single }
          └─StreamTableScan { table: t, columns: [t.id, t.ts], stream_scan_type: ArrangementBackfill, stream_key: [t.ts], pk: [ts], dist: UpstreamHashShard(t.ts) }
  eowc_stream_error: |-
    Not supported: GAP_FILL with EMIT ON WINDOW CLOSE requires a watermark on the time column.
    HINT: Please define a watermark on the time column (column index 1).
- name: in materialized view
  sql: |
    CREATE TABLE t (ts TIMESTAMP, val DOUBLE, PRIMARY KEY(ts));
    CREATE MATERIALIZED VIEW mv AS SELECT * FROM GAP_FILL(t, ts, INTERVAL '1' MINUTE, LOCF(val));
- name: eowc basic with LOCF
  sql: |
    CREATE TABLE t (id INT, ts TIMESTAMP, val DOUBLE, PRIMARY KEY(ts), WATERMARK FOR ts AS ts - INTERVAL '5' SECOND) APPEND ONLY;
    SELECT * FROM GAP_FILL(t, ts, INTERVAL '1' MINUTE, LOCF(val));
  stream_plan: |-
    StreamMaterialize { columns: [id, ts, val], stream_key: [ts], pk_columns: [ts], pk_conflict: NoCheck, watermark_columns: [ts] }
    └─StreamGapFill { time_col: $1, interval: '00:01:00':Interval, fill_strategies: [BoundFillStrategy { strategy: Locf, target_col: $2 }] }
      └─StreamExchange { dist: Single }
        └─StreamTableScan { table: t, columns: [t.id, t.ts, t.val], stream_scan_type: ArrangementBackfill, stream_key: [t.ts], pk: [ts], dist: UpstreamHashShard(t.ts) }
  eowc_stream_plan: |-
    StreamMaterialize { columns: [id, ts, val], stream_key: [ts], pk_columns: [ts], pk_conflict: NoCheck, watermark_columns: [ts] }
    └─StreamEowcGapFill { time_col: $1, interval: '00:01:00':Interval, fill_strategies: [BoundFillStrategy { strategy: Locf, target_col: $2 }] }
      └─StreamExchange { dist: Single }
        └─StreamTableScan { table: t, columns: [t.id, t.ts, t.val], stream_scan_type: ArrangementBackfill, stream_key: [t.ts], pk: [ts], dist: UpstreamHashShard(t.ts) }
  eowc_stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [id, ts, val], stream_key: [ts], pk_columns: [ts], pk_conflict: NoCheck, watermark_columns: [ts] }
    └── StreamEowcGapFill { time_col: $1, interval: '00:01:00':Interval, fill_strategies: [BoundFillStrategy { strategy: Locf, target_col: $2 }] }
        ├── tables: [ EowcGapFillBufferTable: 0, EowcGapFillPrevRowTable: 1 ]
        └── StreamExchange Single from 1

    Fragment 1
    StreamTableScan { table: t, columns: [t.id, t.ts, t.val], stream_scan_type: ArrangementBackfill, stream_key: [t.ts], pk: [ts], dist: UpstreamHashShard(t.ts) }
    ├── tables: [ StreamScan: 2 ]
    ├── Upstream
    └── BatchPlanNode

    Table 0
    ├── columns: [ t_id, t_ts, t_val, _rw_timestamp ]
    ├── primary key: [ $1 ASC ]
    ├── value indices: [ 0, 1, 2 ]
    ├── distribution key: []
    └── read pk prefix len hint: 0

    Table 1
    ├── columns: [ t_id, t_ts, t_val, _rw_timestamp ]
    ├── primary key: [ $0 ASC ]
    ├── value indices: [ 0, 1, 2 ]
    ├── distribution key: []
    └── read pk prefix len hint: 0

    Table 2
    ├── columns: [ vnode, ts, backfill_finished, row_count, _rw_timestamp ]
    ├── primary key: [ $0 ASC ]
    ├── value indices: [ 1, 2, 3 ]
    ├── distribution key: [ 0 ]
    ├── read pk prefix len hint: 1
    └── vnode column idx: 0

    Table 4294967294
    ├── columns: [ id, ts, val, _rw_timestamp ]
    ├── primary key: [ $1 ASC ]
    ├── value indices: [ 0, 1, 2 ]
    ├── distribution key: []
    └── read pk prefix len hint: 1

- name: eowc with INTERPOLATE
  sql: |
    CREATE TABLE t (ts TIMESTAMP, val DOUBLE, PRIMARY KEY(ts), WATERMARK FOR ts AS ts - INTERVAL '5' SECOND) APPEND ONLY;
    SELECT * FROM GAP_FILL(t, ts, INTERVAL '1' MINUTE, INTERPOLATE(val));
  stream_plan: |-
    StreamMaterialize { columns: [ts, val], stream_key: [ts], pk_columns: [ts], pk_conflict: NoCheck, watermark_columns: [ts] }
    └─StreamGapFill { time_col: $0, interval: '00:01:00':Interval, fill_strategies: [BoundFillStrategy { strategy: Interpolate, target_col: $1 }] }
      └─StreamExchange { dist: Single }
        └─StreamTableScan { table: t, columns: [t.ts, t.val], stream_scan_type: ArrangementBackfill, stream_key: [t.ts], pk: [ts], dist: UpstreamHashShard(t.ts) }
  eowc_stream_plan: |-
    StreamMaterialize { columns: [ts, val], stream_key: [ts], pk_columns: [ts], pk_conflict: NoCheck, watermark_columns: [ts] }
    └─StreamEowcGapFill { time_col: $0, interval: '00:01:00':Interval, fill_strategies: [BoundFillStrategy { strategy: Interpolate, target_col: $1 }] }
      └─StreamExchange { dist: Single }
        └─StreamTableScan { table: t, columns: [t.ts, t.val], stream_scan_type: ArrangementBackfill, stream_key: [t.ts], pk: [ts], dist: UpstreamHashShard(t.ts) }
  eowc_stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [ts, val], stream_key: [ts], pk_columns: [ts], pk_conflict: NoCheck, watermark_columns: [ts] }
    └── StreamEowcGapFill { time_col: $0, interval: '00:01:00':Interval, fill_strategies: [BoundFillStrategy { strategy: Interpolate, target_col: $1 }] }
        ├── tables: [ EowcGapFillBufferTable: 0, EowcGapFillPrevRowTable: 1 ]
        └── StreamExchange Single from 1

    Fragment 1
    StreamTableScan { table: t, columns: [t.ts, t.val], stream_scan_type: ArrangementBackfill, stream_key: [t.ts], pk: [ts], dist: UpstreamHashShard(t.ts) }
    ├── tables: [ StreamScan: 2 ]
    ├── Upstream
    └── BatchPlanNode

    Table 0 { columns: [ t_ts, t_val, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 0 }

    Table 1 { columns: [ t_ts, t_val, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 0 }

    Table 2
    ├── columns: [ vnode, ts, backfill_finished, row_count, _rw_timestamp ]
    ├── primary key: [ $0 ASC ]
    ├── value indices: [ 1, 2, 3 ]
    ├── distribution key: [ 0 ]
    ├── read pk prefix len hint: 1
    └── vnode column idx: 0

    Table 4294967294
    ├── columns: [ ts, val, _rw_timestamp ]
    ├── primary key: [ $0 ASC ]
    ├── value indices: [ 0, 1 ]
    ├── distribution key: []
    └── read pk prefix len hint: 1

- name: eowc with KEEPNULL strategy
  sql: |
    CREATE TABLE t (ts TIMESTAMP, name VARCHAR, PRIMARY KEY(ts), WATERMARK FOR ts AS ts - INTERVAL '5' SECOND) APPEND ONLY;
    SELECT * FROM GAP_FILL(t, ts, INTERVAL '1' MINUTE, KEEPNULL(name));
  stream_plan: |-
    StreamMaterialize { columns: [ts, name], stream_key: [ts], pk_columns: [ts], pk_conflict: NoCheck, watermark_columns: [ts] }
    └─StreamGapFill { time_col: $0, interval: '00:01:00':Interval, fill_strategies: [BoundFillStrategy { strategy: Null, target_col: $1 }] }
      └─StreamExchange { dist: Single }
        └─StreamTableScan { table: t, columns: [t.ts, t.name], stream_scan_type: ArrangementBackfill, stream_key: [t.ts], pk: [ts], dist: UpstreamHashShard(t.ts) }
  eowc_stream_plan: |-
    StreamMaterialize { columns: [ts, name], stream_key: [ts], pk_columns: [ts], pk_conflict: NoCheck, watermark_columns: [ts] }
    └─StreamEowcGapFill { time_col: $0, interval: '00:01:00':Interval, fill_strategies: [BoundFillStrategy { strategy: Null, target_col: $1 }] }
      └─StreamExchange { dist: Single }
        └─StreamTableScan { table: t, columns: [t.ts, t.name], stream_scan_type: ArrangementBackfill, stream_key: [t.ts], pk: [ts], dist: UpstreamHashShard(t.ts) }
  eowc_stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [ts, name], stream_key: [ts], pk_columns: [ts], pk_conflict: NoCheck, watermark_columns: [ts] }
    └── StreamEowcGapFill { time_col: $0, interval: '00:01:00':Interval, fill_strategies: [BoundFillStrategy { strategy: Null, target_col: $1 }] }
        ├── tables: [ EowcGapFillBufferTable: 0, EowcGapFillPrevRowTable: 1 ]
        └── StreamExchange Single from 1

    Fragment 1
    StreamTableScan { table: t, columns: [t.ts, t.name], stream_scan_type: ArrangementBackfill, stream_key: [t.ts], pk: [ts], dist: UpstreamHashShard(t.ts) }
    ├── tables: [ StreamScan: 2 ]
    ├── Upstream
    └── BatchPlanNode

    Table 0 { columns: [ t_ts, t_name, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 0 }

    Table 1 { columns: [ t_ts, t_name, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 0 }

    Table 2
    ├── columns: [ vnode, ts, backfill_finished, row_count, _rw_timestamp ]
    ├── primary key: [ $0 ASC ]
    ├── value indices: [ 1, 2, 3 ]
    ├── distribution key: [ 0 ]
    ├── read pk prefix len hint: 1
    └── vnode column idx: 0

    Table 4294967294
    ├── columns: [ ts, name, _rw_timestamp ]
    ├── primary key: [ $0 ASC ]
    ├── value indices: [ 0, 1 ]
    ├── distribution key: []
    └── read pk prefix len hint: 1

- name: eowc mixed strategies
  sql: |
    CREATE TABLE t (ts TIMESTAMP, temp DOUBLE, status VARCHAR, PRIMARY KEY(ts), WATERMARK FOR ts AS ts - INTERVAL '5' SECOND) APPEND ONLY;
    SELECT * FROM GAP_FILL(t, ts, INTERVAL '1' MINUTE, INTERPOLATE(temp), KEEPNULL(status));
  stream_plan: |-
    StreamMaterialize { columns: [ts, temp, status], stream_key: [ts], pk_columns: [ts], pk_conflict: NoCheck, watermark_columns: [ts] }
    └─StreamGapFill { time_col: $0, interval: '00:01:00':Interval, fill_strategies: [BoundFillStrategy { strategy: Interpolate, target_col: $1 }, BoundFillStrategy { strategy: Null, target_col: $2 }] }
      └─StreamExchange { dist: Single }
        └─StreamTableScan { table: t, columns: [t.ts, t.temp, t.status], stream_scan_type: ArrangementBackfill, stream_key: [t.ts], pk: [ts], dist: UpstreamHashShard(t.ts) }
  eowc_stream_plan: |-
    StreamMaterialize { columns: [ts, temp, status], stream_key: [ts], pk_columns: [ts], pk_conflict: NoCheck, watermark_columns: [ts] }
    └─StreamEowcGapFill { time_col: $0, interval: '00:01:00':Interval, fill_strategies: [BoundFillStrategy { strategy: Interpolate, target_col: $1 }, BoundFillStrategy { strategy: Null, target_col: $2 }] }
      └─StreamExchange { dist: Single }
        └─StreamTableScan { table: t, columns: [t.ts, t.temp, t.status], stream_scan_type: ArrangementBackfill, stream_key: [t.ts], pk: [ts], dist: UpstreamHashShard(t.ts) }
  eowc_stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [ts, temp, status], stream_key: [ts], pk_columns: [ts], pk_conflict: NoCheck, watermark_columns: [ts] }
    └── StreamEowcGapFill { time_col: $0, interval: '00:01:00':Interval, fill_strategies: [BoundFillStrategy { strategy: Interpolate, target_col: $1 }, BoundFillStrategy { strategy: Null, target_col: $2 }] }
        ├── tables: [ EowcGapFillBufferTable: 0, EowcGapFillPrevRowTable: 1 ]
        └── StreamExchange Single from 1

    Fragment 1
    StreamTableScan { table: t, columns: [t.ts, t.temp, t.status], stream_scan_type: ArrangementBackfill, stream_key: [t.ts], pk: [ts], dist: UpstreamHashShard(t.ts) } { tables: [ StreamScan: 2 ] }
    ├── Upstream
    └── BatchPlanNode

    Table 0 { columns: [ t_ts, t_temp, t_status, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1, 2 ], distribution key: [], read pk prefix len hint: 0 }

    Table 1 { columns: [ t_ts, t_temp, t_status, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1, 2 ], distribution key: [], read pk prefix len hint: 0 }

    Table 2
    ├── columns: [ vnode, ts, backfill_finished, row_count, _rw_timestamp ]
    ├── primary key: [ $0 ASC ]
    ├── value indices: [ 1, 2, 3 ]
    ├── distribution key: [ 0 ]
    ├── read pk prefix len hint: 1
    └── vnode column idx: 0

    Table 4294967294 { columns: [ ts, temp, status, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1, 2 ], distribution key: [], read pk prefix len hint: 1 }

- name: eowc with timestamptz
  sql: |
    CREATE TABLE t (ts TIMESTAMPTZ, val INT, PRIMARY KEY(ts), WATERMARK FOR ts AS ts - INTERVAL '5' SECOND) APPEND ONLY;
    SELECT * FROM GAP_FILL(t, ts, INTERVAL '1' HOUR, LOCF(val));
  stream_plan: |-
    StreamMaterialize { columns: [ts, val], stream_key: [ts], pk_columns: [ts], pk_conflict: NoCheck, watermark_columns: [ts] }
    └─StreamGapFill { time_col: $0, interval: '01:00:00':Interval, fill_strategies: [BoundFillStrategy { strategy: Locf, target_col: $1 }] }
      └─StreamExchange { dist: Single }
        └─StreamTableScan { table: t, columns: [t.ts, t.val], stream_scan_type: ArrangementBackfill, stream_key: [t.ts], pk: [ts], dist: UpstreamHashShard(t.ts) }
  eowc_stream_plan: |-
    StreamMaterialize { columns: [ts, val], stream_key: [ts], pk_columns: [ts], pk_conflict: NoCheck, watermark_columns: [ts] }
    └─StreamEowcGapFill { time_col: $0, interval: '01:00:00':Interval, fill_strategies: [BoundFillStrategy { strategy: Locf, target_col: $1 }] }
      └─StreamExchange { dist: Single }
        └─StreamTableScan { table: t, columns: [t.ts, t.val], stream_scan_type: ArrangementBackfill, stream_key: [t.ts], pk: [ts], dist: UpstreamHashShard(t.ts) }
  eowc_stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [ts, val], stream_key: [ts], pk_columns: [ts], pk_conflict: NoCheck, watermark_columns: [ts] }
    └── StreamEowcGapFill { time_col: $0, interval: '01:00:00':Interval, fill_strategies: [BoundFillStrategy { strategy: Locf, target_col: $1 }] }
        ├── tables: [ EowcGapFillBufferTable: 0, EowcGapFillPrevRowTable: 1 ]
        └── StreamExchange Single from 1

    Fragment 1
    StreamTableScan { table: t, columns: [t.ts, t.val], stream_scan_type: ArrangementBackfill, stream_key: [t.ts], pk: [ts], dist: UpstreamHashShard(t.ts) }
    ├── tables: [ StreamScan: 2 ]
    ├── Upstream
    └── BatchPlanNode

    Table 0 { columns: [ t_ts, t_val, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 0 }

    Table 1 { columns: [ t_ts, t_val, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 0 }

    Table 2
    ├── columns: [ vnode, ts, backfill_finished, row_count, _rw_timestamp ]
    ├── primary key: [ $0 ASC ]
    ├── value indices: [ 1, 2, 3 ]
    ├── distribution key: [ 0 ]
    ├── read pk prefix len hint: 1
    └── vnode column idx: 0

    Table 4294967294
    ├── columns: [ ts, val, _rw_timestamp ]
    ├── primary key: [ $0 ASC ]
    ├── value indices: [ 0, 1 ]
    ├── distribution key: []
    └── read pk prefix len hint: 1

- name: eowc with projection and filter
  sql: |
    CREATE TABLE t (id INT, ts TIMESTAMP, val DOUBLE, PRIMARY KEY(ts), WATERMARK FOR ts AS ts - INTERVAL '5' SECOND) APPEND ONLY;
    SELECT id, ts FROM GAP_FILL(t, ts, INTERVAL '1' MINUTE, LOCF(val)) WHERE id = 1;
  stream_plan: |-
    StreamMaterialize { columns: [id, ts], stream_key: [ts], pk_columns: [ts], pk_conflict: NoCheck, watermark_columns: [ts] }
    └─StreamFilter { predicate: (t.id = 1:Int32) }
      └─StreamGapFill { time_col: $1, interval: '00:01:00':Interval, fill_strategies: [BoundFillStrategy { strategy: Locf, target_col: $2 }] }
        └─StreamExchange { dist: Single }
          └─StreamTableScan { table: t, columns: [t.id, t.ts], stream_scan_type: ArrangementBackfill, stream_key: [t.ts], pk: [ts], dist: UpstreamHashShard(t.ts) }
  eowc_stream_plan: |-
    StreamMaterialize { columns: [id, ts], stream_key: [ts], pk_columns: [ts], pk_conflict: NoCheck, watermark_columns: [ts] }
    └─StreamFilter { predicate: (t.id = 1:Int32) }
      └─StreamEowcGapFill { time_col: $1, interval: '00:01:00':Interval, fill_strategies: [BoundFillStrategy { strategy: Locf, target_col: $2 }] }
        └─StreamExchange { dist: Single }
          └─StreamTableScan { table: t, columns: [t.id, t.ts], stream_scan_type: ArrangementBackfill, stream_key: [t.ts], pk: [ts], dist: UpstreamHashShard(t.ts) }
  eowc_stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [id, ts], stream_key: [ts], pk_columns: [ts], pk_conflict: NoCheck, watermark_columns: [ts] }
    └── StreamFilter { predicate: (t.id = 1:Int32) }
        └── StreamEowcGapFill { time_col: $1, interval: '00:01:00':Interval, fill_strategies: [BoundFillStrategy { strategy: Locf, target_col: $2 }] }
            ├── tables: [ EowcGapFillBufferTable: 0, EowcGapFillPrevRowTable: 1 ]
            └── StreamExchange Single from 1

    Fragment 1
    StreamTableScan { table: t, columns: [t.id, t.ts], stream_scan_type: ArrangementBackfill, stream_key: [t.ts], pk: [ts], dist: UpstreamHashShard(t.ts) }
    ├── tables: [ StreamScan: 2 ]
    ├── Upstream
    └── BatchPlanNode

    Table 0 { columns: [ t_id, t_ts, _rw_timestamp ], primary key: [ $1 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 0 }

    Table 1 { columns: [ t_id, t_ts, _rw_timestamp ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [], read pk prefix len hint: 0 }

    Table 2
    ├── columns: [ vnode, ts, backfill_finished, row_count, _rw_timestamp ]
    ├── primary key: [ $0 ASC ]
    ├── value indices: [ 1, 2, 3 ]
    ├── distribution key: [ 0 ]
    ├── read pk prefix len hint: 1
    └── vnode column idx: 0

    Table 4294967294
    ├── columns: [ id, ts, _rw_timestamp ]
    ├── primary key: [ $1 ASC ]
    ├── value indices: [ 0, 1 ]
    ├── distribution key: []
    └── read pk prefix len hint: 1

- name: too few arguments
  sql: |
    CREATE TABLE t (ts TIMESTAMP, val DOUBLE);
    SELECT * FROM GAP_FILL(t, ts);
  binder_error: 'Bind error: GAP_FILL requires at least 3 arguments: input, time_col, interval'
- name: non-timestamp time column
  sql: |
    CREATE TABLE t (ts INT, val DOUBLE);
    SELECT * FROM GAP_FILL(t, ts, INTERVAL '1' MINUTE);
  binder_error: 'Bind error: The 2nd arg of GAP_FILL should be a column of type timestamp or timestamptz'
- name: non-interval argument
  sql: |
    CREATE TABLE t (ts TIMESTAMP, val DOUBLE);
    SELECT * FROM GAP_FILL(t, ts, 60);
  binder_error: 'Bind error: The 3rd arg of GAP_FILL should be an interval'
- name: interpolate non-numeric type
  sql: |
    CREATE TABLE t (ts TIMESTAMP, name VARCHAR);
    SELECT * FROM GAP_FILL(t, ts, INTERVAL '1' MINUTE, INTERPOLATE(name));
  binder_error: 'Bind error: INTERPOLATE only supports numeric types, got character varying'
- name: interpolate on timestamp column
  sql: |
    CREATE TABLE t (ts TIMESTAMP, val DOUBLE, PRIMARY KEY(ts));
    SELECT * FROM GAP_FILL(t, ts, INTERVAL '1' MINUTE, INTERPOLATE(ts));
  binder_error: 'Bind error: INTERPOLATE only supports numeric types, got timestamp without time zone'
- name: unsupported fill strategy
  sql: |
    CREATE TABLE t (ts TIMESTAMP, val DOUBLE);
    SELECT * FROM GAP_FILL(t, ts, INTERVAL '1' MINUTE, UNKNOWN(val));
  binder_error: 'Bind error: Unsupported fill strategy: unknown'
- name: fill strategy with no arguments
  sql: |
    CREATE TABLE t (ts TIMESTAMP, val DOUBLE);
    SELECT * FROM GAP_FILL(t, ts, INTERVAL '1' MINUTE, LOCF());
  binder_error: 'Bind error: Fill strategy function locf expects exactly one argument'
- name: fill strategy with multiple arguments
  sql: |
    CREATE TABLE t (ts TIMESTAMP, v1 DOUBLE, v2 DOUBLE);
    SELECT * FROM GAP_FILL(t, ts, INTERVAL '1' MINUTE, LOCF(v1, v2));
  binder_error: 'Bind error: Fill strategy function locf expects exactly one argument'
- name: fill strategy with expression
  sql: |
    CREATE TABLE t (ts TIMESTAMP, val DOUBLE);
    SELECT * FROM GAP_FILL(t, ts, INTERVAL '1' MINUTE, LOCF(val + 1));
  binder_error: 'Bind error: Fill strategy argument must be a column reference'
- name: zero interval
  sql: |
    CREATE TABLE t (ts TIMESTAMP, val DOUBLE, PRIMARY KEY(ts));
    SELECT * FROM GAP_FILL(t, ts, INTERVAL '0' SECOND, LOCF(val));
  binder_error: 'Bind error: The gap fill interval cannot be zero'
